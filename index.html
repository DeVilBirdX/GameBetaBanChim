<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShotBird</title>
    <style>
        body {
    font-family: Arial, sans-serif;
    text-align: center;
    background-color: #CCFFFF;
        }
        .fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            background-color: #00FFCC;
            overflow: hidden; 
        }
        #gameCanvas {
            border: 1px solid #00FFCC;
            display: block;
            margin: 0 auto;
            background-image: url('https://allimages.sgp1.digitaloceanspaces.com/tipeduvn/2022/08/1660671018_77_Bo-suu-tap-hinh-nen-vu-tru-4K-doc-dao.jpg');
            background-size: cover; 
            background-repeat: no-repeat;
        }
        #playAgainButton {
            display: none; 
            position: absolute; 
            left: 50%; 
            top: 65%; 
            transform: translate(-50%, -50%);
            font-weight: bold; 
            color: green; 
        }
        .musicButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        .youtubeButton {
        display: inline-block;
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        background-color: #FF6600; 
        border-radius: 5px; 
        }
        .youtubeButton button {
        background: none;
        border: none;
        padding: 0;
        font: inherit;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        }
        .youtubeButton img {
        width: 50px; 
        height: 50px; 
        margin-right: 10px; 
        }
        .youtubeLabel {
        color: white; 
        font-weight: bold; 
        }
        #sideMenu {
        margin: 0; 
        position: fixed;
        top: 0;
        right: -100%; 
        width: 50%; 
        height: 100%;
        background-color: white;
        box-shadow: -2px 0 5px rgba(0, 0, 0, 0.5);
        z-index: 999;
        transition: right 0.3s ease;
        padding-top: 60px; 
        text-align: left; 
        padding-left: 20px; 
        }
        #sideMenu.open {
        right: 0; 
        }
        #menuIcon {
        position: fixed;
        top: 10px;
        left: 10px;
        font-size: 24px;
        cursor: pointer;
        }
        .newModeDecoration {
        font-size: 30px; 
        font-weight: bold;
        text-align: center;
        margin-bottom: 20px; 
        animation: rainbow 3s linear infinite;
        }
        .rainbow-text {
        font-size: 36px; 
        font-weight: bold; 
        text-align: center; 
        animation: rainbow 8s linear infinite; 
        }
        @keyframes rainbow {
        0% { color: #FF0000; }
        14% { color: #FF7F00; }
        28% { color: #FFFF00; }
        42% { color: #00FF00; }
        57% { color: #0000FF; }
        71% { color: #4B0082; }
        85% { color: #8B00FF; }
        100% { color: #FF0000; }
        }
        .custom-button {
        display: inline-block;
        padding: 10px 20px;
        font-size: 20px;
        background-color: gold;
        color: red;
        border: none;
        cursor: pointer;
        border-radius: 5px;
        transition: background-color 0.3s;
        }
        .custom-button:hover {
        background-color: #CCFF00; 
        }
        .custom-text {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        font-size: 20px;
        font-weight: bold;
        color: yellow;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); 
        }
    </style>
</head>
<body>
    <div id="sideMenu">
    <div class="newModeDecoration">
        CHáº¾ Äá»˜ Má»šI
    </div>
<a class="custom-button" id="game1" href="https://devilbirdx.github.io/BETAANHBASIN/" target="_blank">ğ—›ğ—”ğ—¡ğ—› ğ—§ğ—¥ğ—œğ—¡ğ—› ğ—”ğ—¡ğ—› ğ—•ğ—” ğ—¦ğ—œğ—¡</a>
    <a href="#section2">HÃƒY TRáº¢I NGHIá»†M,</a>
    <a href="#section3">CHÃšC VUI Váºº...</a>
</div>
    <button id="menuIcon">â˜°</button>
    <button id="fullscreenButton" class="fullscreenButton">[ğ—™ğ—¨ğ—Ÿğ—Ÿ ğ—¦ğ—–ğ—¥ğ—˜ğ—˜ğ—¡]</button>
    <h1 class="rainbow-text">Demon Bird Apocalypse</h1>
    <canvas id="gameCanvas" width="400" height="500"></canvas>
    <button id="playAgainButton" class="musicButton">PÌ²ÅÄ€á»´ Ã…ÄÃ„Ä®Å‡</button>
</div>
    <button id="musicButton1" class="musicButton">ğ— ğ—¨ğ—¦ğ—œğ—– ğŸ­</button>
    <button id="musicButton2" class="musicButton">ğ— ğ—¨ğ—¦ğ—œğ—– ğŸ®</button>
    <div class="youtubeButton" id="youtubeButton">
    <button onclick="window.open('https://devilbirdx.github.io/GameBetaBanChim', '_blank')">
    <img src="https://cdn.pixabay.com/photo/2020/11/01/04/17/youtube-5702828_1280.png">
<span class="youtubeLabel">ğŒğ˜ ğ‚ğ‡ğ€ğğğ„ğ‹</span>
    </button>
</div>
<audio id="backgroundMusic1" src="https://firebasestorage.googleapis.com/v0/b/nhachay-43b11.appspot.com/o/Y2meta.app%20-%20Em%20L%C3%A0%20Nh%E1%BA%A5t%20(Speed%20Up)%20-%20kis%20x%20Ho%C3%A0ng%20KayLee%20x%20Yahy%E3%80%8CCukak%20Remix%20%E3%80%8D_%20Audio%20Lyric%20(320%20kbps).mp3?alt=media&token=54c12e54-730c-4c1e-9816-bd27efdac040" preload="auto" loop></audio>
<audio id="backgroundMusic2" src="https://firebasestorage.googleapis.com/v0/b/nhachay-43b11.appspot.com/o/X2Download.app%20-%20Alan%20Walker%20-%20Spectre%20%5BCOPYRIGHTED%20NCS%20Release%5D%20(320%20kbps).mp3?alt=media&token=11486c06-19d9-4049-b3b0-3acd343c2d94" preload="auto" loop></audio>
    <script>
document.getElementById('youtubeButton').addEventListener('click', function() {
        });
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const planeWidth = 60;
const planeHeight = 30;
const enemySize = 30;
const bulletWidth = 8;
const bulletHeight = 13;
let planeX = canvas.width / 2 - planeWidth / 2;
const planeY = canvas.height - planeHeight - 10;
let enemies = [];
let bullets = [];
let bombs = []; 
let score = 0;
let lives = 5;
let isGameOver = false;
let isBossFight = false;
let boss = null;
let bossHealthIncrementCount = 0;
let enemyInterval = 1700;
let isDragging = false;
const scoreIntervalDecrease = 300;
const maxEnemyIntervalDecrease = 1500;       

const fullscreenButton = document.getElementById('fullscreenButton');
fullscreenButton.addEventListener('click', function() {
    toggleFullscreen();
});


function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
        document.body.classList.add('fullscreen'); 
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
            document.body.classList.remove('fullscreen'); 
        }
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const menuIcon = document.getElementById('menuIcon');
    const sideMenu = document.getElementById('sideMenu');
    const toggleMenuButton = document.getElementById('toggleMenuButton');

    function toggleSideMenu() {
        sideMenu.classList.toggle('open');
        if (sideMenu.classList.contains('open')) {
            menuIcon.textContent = 'âŒ';
        } else {
            menuIcon.textContent = 'â˜°';
        }
    }

    menuIcon.addEventListener('click', toggleSideMenu);
    toggleMenuButton.addEventListener('click', toggleSideMenu);
});

const flyTulenSize = 30; 
let flyTulens = []; 

function createFlyTulen() {
    if (Math.random() < 0.03) { 
        const x = Math.random() * (canvas.width - flyTulenSize);
        flyTulens.push({ x: x, y: -flyTulenSize });
    }
}

function drawFlyTulens() {
    flyTulens.forEach(flyTulen => {
        ctx.fillStyle = 'orange';
        ctx.beginPath();
        ctx.arc(flyTulen.x + flyTulenSize / 2, flyTulen.y + flyTulenSize / 2, flyTulenSize / 2, 0, Math.PI * 2);
        ctx.fill();
    });
}

function updateFlyTulens() {
    flyTulens.forEach((flyTulen, index) => {
        flyTulen.y += 2;

        if (flyTulen.y > canvas.height) {
            flyTulens.splice(index, 1);
        }

        if (flyTulen.x < planeX + planeWidth &&
            flyTulen.x + flyTulenSize > planeX &&
            flyTulen.y < planeY + planeHeight &&
            flyTulen.y + flyTulenSize > planeY) {
            flyTulens.splice(index, 1);
            lives--;
            if (lives <= 0) {
                isGameOver = true;
            }
        }
    });
}

function createBomb(enemy) {
    return {
        x: enemy.x,
        y: enemy.y + enemySize, 
        dy: 2.5  
    };
}

function updateBombs() {
    bombs.forEach((bomb, index) => {
        bomb.y += bomb.dy;

        
        if (bomb.y + 10 > planeY && bomb.y < planeY + planeHeight && bomb.x > planeX && bomb.x < planeX + planeWidth) {
            bombs.splice(index, 1);
            lives--; 
            if (lives <= 0) {
                isGameOver = true;
            }
        }

        
        if (bomb.y > canvas.height) {
            bombs.splice(index, 1);
        }
    });
}


function drawBombs() {
    bombs.forEach(bomb => {
        ctx.beginPath(); 
        ctx.arc(bomb.x, bomb.y, 5, 0, Math.PI * 2); 
        ctx.fillStyle = 'yellow';
        ctx.fill(); 
        ctx.closePath(); 
    });
}

        
        function createBoss() {
    boss = {
        x: canvas.width / 2 - enemySize * 2,
        y: 100,
        width: enemySize * 4,
        height: enemySize * 4,
        health: 100,
        speedX: 2,  
        direction: 1,  
        bullets: []
    };
}
        
        function drawBoss() {
    if (boss) {
        ctx.fillStyle = 'magenta';
        ctx.beginPath();
        ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2, boss.width / 2, 0, Math.PI * 2);
        ctx.fill();

        
        ctx.fillStyle = 'magenta';
        for (let i = 0; i < 8; i++) {
            ctx.save();
            ctx.translate(boss.x + boss.width / 2, boss.y + boss.height / 2);
            ctx.rotate(i * Math.PI / 4);
            ctx.fillRect(-boss.width / 2, -boss.height / 2, boss.width, boss.height / 2);
            ctx.restore();
        }

        
        boss.bullets.forEach(bullet => {
            ctx.fillStyle = 'turquoise';
            ctx.fillRect(bullet.x, bullet.y, bulletWidth, bulletHeight);
        });

        
        ctx.fillStyle = 'orangered';
        ctx.font = '20px Arial'; 
        ctx.fillText(`BOSS HP: ${boss.health}`, boss.x + boss.width / 2 - ctx.measureText(`BOSS HP: ${boss.health}`).width / 2, boss.y + boss.height / 2 + 10);
    }
}
       
function updateBoss() {
    if (boss) {
        boss.x += boss.speedX * boss.direction;

        if (boss.x <= 0 || boss.x + boss.width >= canvas.width) {
            boss.direction *= -1;
        }

        if (Math.random() < 0.02) {
            for (let i = 0; i < 3; i++) {
                boss.bullets.push({
                    x: boss.x + boss.width / 2,
                    y: boss.y + boss.height,
                    dx: (Math.random() - 0.5) * 3,
                    dy: 4
                });
            }
        }

        if (Math.random() < 0.003) {
            const numBombs = Math.floor(Math.random() * 3) + 1;
            const angleIncrement = (Math.PI * 2) / numBombs;
            let currentAngle = 0;

            for (let i = 0; i < numBombs; i++) {
                bombs.push(createCircularBomb(boss, currentAngle));
                currentAngle += angleIncrement;
            }
        }

        if (Math.random() < 0.03) { 
            const x = Math.random() * (canvas.width - flyTulenSize);
            flyTulens.push({ x: x, y: -flyTulenSize });
        }

        flyTulens.forEach((flyTulen, index) => {
            flyTulen.y += 2;

            if (flyTulen.y > canvas.height) {
                flyTulens.splice(index, 1);
            }

            if (flyTulen.x < planeX + planeWidth &&
                flyTulen.x + flyTulenSize > planeX &&
                flyTulen.y < planeY + planeHeight &&
                flyTulen.y + flyTulenSize > planeY) {
                flyTulens.splice(index, 1);
                lives--;
                if (lives <= 0) {
                    isGameOver = true;
                }
            }
        });

        boss.bullets.forEach((bullet, index) => {
            bullet.x += bullet.dx;
            bullet.y += bullet.dy;

            if (bullet.y > canvas.height || bullet.x < 0 || bullet.x > canvas.width) {
                boss.bullets.splice(index, 1);
            }

            if (bullet.y + bulletHeight > planeY &&
                bullet.y < planeY + planeHeight &&
                bullet.x + bulletWidth > planeX &&
                bullet.x < planeX + planeWidth) {
                boss.bullets.splice(index, 1);
                lives--;
                if (lives <= 0) {
                    isGameOver = true;
                }
            }
        });
    }
}

function createCircularBomb(boss, angle) {
    const radius = boss.width / 2;
    const centerX = boss.x + boss.width / 2;
    const centerY = boss.y + boss.height / 2;
    const speed = 1.5;

    return {
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle),
        dy: speed
    };
}

        function checkBossCollision() {
    bullets.forEach((bullet, bulletIndex) => {
        if (boss && bullet.x < boss.x + boss.width &&
            bullet.x + bulletWidth > boss.x &&
            bullet.y < boss.y + boss.height &&
            bullet.y + bulletHeight > boss.y) {
            bullets.splice(bulletIndex, 1);
            boss.health--;

            if (boss.health <= 0) {
                boss = null;
                score += 3;  
                lives += 2;  
                isBossFight = false;
            }
        }
    });
}

        function drawPlane() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); 

            
            ctx.fillStyle = 'yellow';
            ctx.fillRect(planeX, planeY + planeHeight * 0.3, planeWidth, planeHeight * 0.4);

            ctx.fillStyle = 'mediumslateblue';
            ctx.fillRect(planeX + planeWidth * 0.2, planeY + planeHeight * 0.1, planeWidth * 0.6, planeHeight * 0.2);

            ctx.fillStyle = 'chartreuse';
            ctx.beginPath();
            ctx.moveTo(planeX + planeWidth * 0.4, planeY);
            ctx.lineTo(planeX + planeWidth * 0.3, planeY - planeHeight * 0.2);
            ctx.lineTo(planeX + planeWidth * 0.7, planeY - planeHeight * 0.2);
            ctx.lineTo(planeX + planeWidth * 0.6, planeY);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'aquamarine';
            ctx.beginPath();
            ctx.moveTo(planeX + planeWidth * 0.4, planeY + planeHeight * 0.3);
            ctx.lineTo(planeX + planeWidth * 0.6, planeY + planeHeight * 0.3);
            ctx.lineTo(planeX + planeWidth * 0.5, planeY + planeHeight * 0.1);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'olivedrab';
            ctx.beginPath();
            ctx.arc(planeX + planeWidth * 0.5, planeY + planeHeight * 0.8, planeWidth * 0.1, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEnemies() {
    enemies.forEach(enemy => {
        ctx.fillStyle = 'dodgerblue';
        ctx.beginPath();
        ctx.moveTo(enemy.x, enemy.y);
        ctx.quadraticCurveTo(enemy.x - enemySize / 2, enemy.y + enemySize / 2, enemy.x, enemy.y + enemySize);
        ctx.quadraticCurveTo(enemy.x + enemySize / 2, enemy.y + enemySize / 2, enemy.x, enemy.y);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'lime';
        ctx.beginPath();
        ctx.arc(enemy.x - enemySize * 0.15, enemy.y + enemySize * 0.1, enemySize * 0.1, 0, Math.PI * 2);
        ctx.arc(enemy.x + enemySize * 0.15, enemy.y + enemySize * 0.1, enemySize * 0.1, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'lime';
        ctx.beginPath();
        ctx.arc(enemy.x - enemySize * 0.15, enemy.y + enemySize * 0.1, enemySize * 0.05, 0, Math.PI * 2);
        ctx.arc(enemy.x + enemySize * 0.15, enemy.y + enemySize * 0.1, enemySize * 0.05, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'lime';
        ctx.beginPath();
        ctx.moveTo(enemy.x - enemySize / 2, enemy.y + enemySize / 4);
        ctx.quadraticCurveTo(enemy.x, enemy.y - enemySize / 2, enemy.x + enemySize / 2, enemy.y + enemySize / 4);
        ctx.closePath();
        ctx.fill();
            });
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.fillStyle = 'MediumSpringGreen';
                ctx.beginPath();
                ctx.moveTo(bullet.x, bullet.y - bulletHeight); 
                ctx.lineTo(bullet.x - bulletWidth / 2, bullet.y); 
                ctx.lineTo(bullet.x + bulletWidth / 2, bullet.y); 
                ctx.closePath();
                ctx.fill();
            });
        }

        
        function updateBullets() {
            bullets.forEach((bullet, index) => {
                bullet.y -= 5;
                if (bullet.y < 0) {
                    bullets.splice(index, 1);
                }
            });
        }

        function drawScoreAndLives() {
        ctx.font = 'bold 25px Arial'; 
        ctx.fillStyle = 'gold';
        ctx.fillText(`SCORE: ${score}`, 10, 30); 
        ctx.fillText(`LIFE: ${lives}`, canvas.width - 100, 30); 
        }

        function movePlane(event) {
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            if (clickX > 0 && clickX < canvas.width) {
                planeX = clickX - planeWidth / 2;
            if (planeX < 0) {
                planeX = 0;
            } else if (planeX > canvas.width - planeWidth) {
                planeX = canvas.width - planeWidth;
            }
        }
    }

        function movePlaneTouch(event) {
            const touchX = event.touches[0].clientX - canvas.offsetLeft;
            if (touchX > 0 && touchX < canvas.width) { 
                planeX = touchX - planeWidth / 2;

                
                if (planeX < 0) {
                    planeX = 0;
                } else if (planeX > canvas.width - planeWidth) {
                    planeX = canvas.width - planeWidth;
                }
            }
        }

        
        function shootBullet() {
            bullets.push({ x: planeX + planeWidth / 2, y: planeY });
        }

        
        setInterval(shootBullet, 100);

        function updateEnemies() {
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        enemy.y += 3; 
                
        enemy.x += enemy.dx; 

        
        if (enemy.x < enemySize / 2) {
            enemy.x = enemySize / 2;
            enemy.dx *= -1; 
        } else if (enemy.x > canvas.width - enemySize / 2) {
            enemy.x = canvas.width - enemySize / 2;
            enemy.dx *= -1; 
        }

        
        if (enemy.y > canvas.height) {
            enemies.splice(i, 1);
            lives--;
            if (lives <= 0) {
                isGameOver = true;
            }
            continue;
        }

        
        if (enemy.x > planeX && enemy.x < planeX + planeWidth && enemy.y + enemySize > planeY && enemy.y < planeY + planeHeight) {
            enemies.splice(i, 1);
            lives--;
            if (lives <= 0) {
                isGameOver = true;
            }
            continue;
        }
        
        if (!enemy.hasDroppedBomb && Math.random() < 0.01) { 
            bombs.push(createBomb(enemy));
            enemy.hasDroppedBomb = true;
        }
    }
}

        function checkCollisions() {
    bullets.forEach((bullet, bulletIndex) => {
        enemies.forEach((enemy, enemyIndex) => {
            if (bullet.x > enemy.x - enemySize / 2 &&
                bullet.x < enemy.x + enemySize / 2 &&
                bullet.y > enemy.y - enemySize / 2 &&
                bullet.y < enemy.y + enemySize / 2) {
                bullets.splice(bulletIndex, 1);
                enemies.splice(enemyIndex, 1);
                score++;

                if (score % scoreIntervalDecrease === 0 && enemyInterval > maxEnemyIntervalDecrease) {
                    enemyInterval -= 30;
                }

                if (score % 100 === 0 && score > 0 && !isBossFight) {
                    createBoss();
                    isBossFight = true;
                    if (boss) {
                        boss.bullets = [];
                    }
                }

                if (score >= 200 * (bossHealthIncrementCount + 1)) {
                    if (boss) {
                        boss.health += 10;
                    }
                    bossHealthIncrementCount++;
                }
            }
        });

        flyTulens.forEach((flyTulen, flyTulenIndex) => {
            if (bullet.x > flyTulen.x &&
                bullet.x < flyTulen.x + flyTulenSize &&
                bullet.y > flyTulen.y &&
                bullet.y < flyTulen.y + flyTulenSize) {
                bullets.splice(bulletIndex, 1);
                flyTulens.splice(flyTulenIndex, 1);
                score++;
            }
        });
    });
}

        const averageEnemyInterval = 1700; 
        let lastEnemyCreationTime = 0;
        let enemyCount = 0;

        function createEnemy() {
    if (!isBossFight && Date.now() - lastEnemyCreationTime > enemyInterval) {
        const numEnemies = Math.floor(Math.random() * 2) + 2;
        for (let i = 0; i < numEnemies; i++) {
            const x = Math.random() * (canvas.width - enemySize) + enemySize / 2;
            const dx = (Math.random() - 0.5) * 2; 
            enemies.push({ x: x, y: -enemySize, dx: dx });
        }
        lastEnemyCreationTime = Date.now();
        enemyCount += numEnemies;
    }
}

document.getElementById('game1').addEventListener('click', function(event) {
        event.preventDefault();

        window.open('https://devilbirdx.github.io/BETAANHBASIN/', '_blank');
    });
        
function resetGame() {    
    planeX = canvas.width / 2 - planeWidth / 2;
    enemies = [];
    bullets = [];
    bombs = [];
    score = 0;
    lives = 5;
    isGameOver = false;
    isBossFight = false;
    boss = null;
    bossHealthIncrementCount = 0;
    enemyInterval = 1700;
    lastEnemyCreationTime = 0;
    flyTulens = [];  
    playAgainButton.style.display = 'none';
    updateGame();
}

const playAgainButton = document.getElementById('playAgainButton');
playAgainButton.addEventListener('click', resetGame);

function updateGame() {
    if (isGameOver) {
        ctx.font = '30px Arial';
        ctx.fillStyle = 'red';
        ctx.fillText('ğ†ğ€ğŒğ„ ğğ•ğ„ğ‘', canvas.width / 2 - 80, canvas.height / 2);
        playAgainButton.style.display = 'block';
    } else {
        playAgainButton.style.display = 'none'; 
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawPlane();

        if (isBossFight) {
            drawBoss();
            updateBoss();
            checkBossCollision();
            drawFlyTulens();
            updateFlyTulens();
        } else {
            drawEnemies();
            updateEnemies();
            createEnemy();
        }

        updateBullets();
        drawBullets();
        checkCollisions();

        drawBombs();
        updateBombs();

        drawScoreAndLives();
        requestAnimationFrame(updateGame);
    }
}

canvas.addEventListener('mousedown', function(event) {
    isDragging = true;
    movePlane(event);
});
canvas.addEventListener('mousemove', function(event) {
    if (isDragging) {
        movePlane(event);
    }
});
canvas.addEventListener('mouseup', function() {
    isDragging = false;
});
canvas.addEventListener('mouseleave', function() {
    isDragging = false;
});
document.addEventListener('keydown', movePlane);
canvas.addEventListener('mousedown', movePlane);
canvas.addEventListener('touchstart', movePlaneTouch);
canvas.addEventListener('touchmove', movePlaneTouch);
        
        updateGame();

const backgroundMusic1 = document.getElementById('backgroundMusic1');
const backgroundMusic2 = document.getElementById('backgroundMusic2');

document.getElementById('musicButton1').addEventListener('click', function() {
    backgroundMusic1.play();
});

document.getElementById('musicButton2').addEventListener('click', function() {
    backgroundMusic2.play();
});
</script>
</body>
</html>
